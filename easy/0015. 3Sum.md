# 3Sum
> https://leetcode.com/problems/3sum/description/

## TIL

- binary search 사용하면 안된다. 



## c.f Binary 사용 실패 예

```py
# Binary Search Try, but don't
# O(n * 2logn) = O(nlogn)
# Binary search를 하면 안된다. 왜냐하면 i+1, k-1이 번갈아가면서 하기때문에
# 다음과 같은 상황을 처리할 수 없다.[ixxxxxxxjkxxxxxx]


from typing import Literal


class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        def binary_search(i, k):
            nonlocal nums

            target = -(nums[i] + nums[k])
            limited_nums = nums[i+1: k] # i+1 ~ k-1
            n = len(limited_nums)
            if n == 0:
                return None

            s, e = 0, n-1
            while s<=e:
                mid = (s + e) // 2
                if limited_nums[mid] == target:
                    return target
                elif limited_nums[mid] < target:
                    s = mid + 1
                else:
                    e = mid -1
            return None
        
        def skip_duplicate(i: int, direction: Literal[-1, 1]= 1):
            nonlocal nums
            # TODO: add boundary 
            n = len(nums)
            nxt = i + direction
            while 1<= nxt < n -1 and nums[nxt] == nums[i]:
                nxt += direction
            return nxt 

        n = len(nums)
        nums.sort()
        
        results = []
        i, k = 0, n-1
        first_try = True
        while i < k:
            if first_try:
                # 1. binary_search(i, k)
                j_value = binary_search(i, k)
                if j_value is not None:
                    results.append([nums[i], j_value, nums[k]])
                first_try = False
            
            # 2. binary_search(i+1, k)
            i = skip_duplicate(i)
            # 0 < i < j < k < 0, cannot make answer
            if nums[i] > 0: 
                break
            j_value = binary_search(i, k)
            if j_value is not None:
                results.append([nums[i], j_value, nums[k]])

            # 3. binary_search(i+1, k-1)
            k = skip_duplicate(k, direction=-1)
            j_value = binary_search(i, k)
            if j_value is not None:
                results.append([nums[i], j_value, nums[k]])
        
        return results

```


```
[-2,0,1,1,2]

Use Testcase
Output
[[-2,0,2]]
Expected
[[-2,0,2],[-2,1,1]]
```